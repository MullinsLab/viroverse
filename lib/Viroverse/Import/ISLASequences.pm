use strict;
use warnings;
use utf8;
use 5.018;

package Viroverse::Import::ISLASequences;
use Moo;
use Types::Standard -types;
use Viroverse::Logger qw< :log :dlog >;
use ViroDB;
use Viroverse::CachingFinder;
use Viroverse::Types -types;
use namespace::clean;
use Viroverse::Config;

with 'Viroverse::Import',
     'Viroverse::Import::HasCreatingScientist';

=head1 DESCRIPTION

This importer is for loading integration site sequences generated by the
Frenkel lab using the ISLA protocol into Viroverse. It's intended to load
sequences from ICE cultures, so it looks up B<T cell lysate> samples by sample
name and processes rows as follows:

=over

=item *

If no matching sample is found, it skips processing that row further, but does
not fail the entire job.

=item *

If the sample has more than one ISLA sequence with the same name, the job fails.
Our process for getting these sequences into Viroverse currently requires that
we use the sequence name as a candidate key. The names are unique for the time
being, but when that assumption is violated we'll need to fix something.

=item *

If the sample has a sequence with the same name and contents, it does nothing,
to allow idempotent/upsert loading of the same source file with this importer.

=item *

If an existing sequence has the same name but different contents, it assumes a
correction has been made and creates a new revision of the existing sequence.

=item *

Otherwise, it inserts a new sequence.

=back

=cut

has '+key_map' => (
    isa => Dict[
        sample_name    => Str,
        sequence_name  => Str,
        sequence       => Str,
        scientist_name => Str,
    ],
);

has _scientists => (
    is      => 'ro',
    isa     => InstanceOf["Viroverse::CachingFinder"],
    default => sub { Viroverse::CachingFinder->new(
        resultset => ViroDB->instance->resultset("Scientist"),
        field     => "name",
    )},
);

sub is_enabled {
    return Viroverse::Config->conf->{features}->{isla_sequences};
}

sub suggested_column_for_key_pattern {
    my ($package, $key) = @_;
    return {
        sample_name     => qr/sample_name|sample/i,
        sequence_name   => qr/sequence_name|name/i,
        sequence        => qr/sequence(?!.*?name)/i,
        scientist_name  => qr/scientist/i,
    }->{$key};
}

sub process_row {
    my ($self, $row) = @_;
    state $db = ViroDB->instance;

    state $isla_type = $db->resultset("SequenceType")->find({ 'name' => 'ISLA', });

    my $sample = $db->resultset("Sample")->search(
        { 'me.name' => $row->{sample_name}, 'tissue_type.name' => "T cell lysate" },
        { join => "tissue_type" },
    )->single;
    unless ($sample) {
        log_warn {[ "Couldn't find a T cell lysate named %s", $row->{sample_name} ]};
        $self->track("Sample not found");
        return;
    }
    log_debug {[ "Found sample ID: %s", $sample->id ]};

    # If this row isn't labeled with a scientist, fall back to
    # the job's scientist. Otherwise, look them up by name.
    my $scientist = (not $row->{scientist_name})
        ? $self->creating_scientist
        : $self->_scientists->find($row->{scientist_name});

    my @existing_seqs = $sample->search_related("na_sequences", {
        'me.name'        => $row->{sequence_name},
        sequence_type_id => $isla_type->id,
    }, {
        join => [qw[ latest_revision ]],
    });

    if (@existing_seqs > 1) {
        log_error {[ "Sequence name collision: sample %s, sequence name %s",
                     $sample->id,
                     $row->{sequence_name} ]};
        die "Sequence name collision" if @existing_seqs > 1;
    }

    my $existing_seq = @existing_seqs && $existing_seqs[0]->get_from_storage;

    if ($existing_seq) {
        if ($existing_seq->sequence_bases eq $row->{sequence}) {
            log_debug {[ "Sequence %s already present for sample %s",
                         $existing_seq->idrev,
                         $sample->id ]};
            $self->track("Sequence already exists");
        } else {
            my $new_revision = $existing_seq->create_revision({
                sequence     => $row->{sequence},
            });
            log_info {[ "Added revised sequence %s for sample %s",
                         $new_revision->idrev,
                         $sample->id ]};
            $self->track("Revised existing sequence");
        }
    } else {
        my $seq = $db->resultset("NucleicAcidSequence")->create({
            name         => $row->{sequence_name},
            na_sequence_revision => 1,
            sequence     => $row->{sequence},
            scientist_id => $scientist->id,
            sample_id    => $sample->id,
            na_type      => "DNA", # XXX hardcoded
            type         => $isla_type,
        });
        log_info{[ "Inserted new sequence %s on sample %s", $seq->idrev, $sample->id ]};
        $self->track("Inserted new sequence");
    }
}

1;
